#!/usr/bin/perl
#
# Tell us (by default) the earliest causal path of commits and merges to
# cause the requested commit got onto a named branch.  If a commit was
# made directly on a named branch, that obviously is the earliest path.
#
# See the pod documentation below for more information
#
# Thanks to Artur Skawina for his assistance in developing some
# of the algorithms used by this script.
#
# License: GPL v2
# Copyright (c) 2010 Seth Robertson
#
use warnings;
no warnings "uninitialized";
use Getopt::Long;
use strict;

my $USAGE="$0: [--allref] [--all] [--quiet] [--reference-branch=branchname] [--reference=reference] [--version] <commit-hash/tag>...

--allref
	Consider even remote branches as candidates for the branch a
	reference is on

--all
	Print all reachable branch names (and merge paths)

--quiet
	Print only the branch names, not the merge paths

--reference-branch <branchname>
	The command line arguments/reference are searched to see if
	they can reach this branch.

--reference <hash|tag>
	Specify a particular commit you which you want to
	know how the commit in question was reached

--topo-order
--date-order
	By default we select the merge path which merged earliest into
	a specific named commit (--date-order).  Instead we can select
	--topo-order which will select the minimum number of merges.

--version
	Determine the version of the installed program.
";

my(%OPTIONS);
Getopt::Long::Configure("bundling", "no_ignore_case", "no_auto_abbrev", "no_getopt_compat", "require_order");
GetOptions(\%OPTIONS, 'a|allref', 'all', 'quiet', 'debug', 'reference-branch=s', 'reference=s', 'verbose|v+', 'version', 'topo-order', 'date-order') || die $USAGE;

if ($OPTIONS{'version'})
{
  print "$0 version is {UNTAGGED}\n";
  exit(0);
}


my ($OPT_A);
$OPT_A="-a" if ($OPTIONS{'a'});

if ( $#ARGV < 0 )
{
    print STDERR $USAGE;
    exit(2);
}

my ($MULTI);
$MULTI=1 if ( $#ARGV > 0 );



########################################
#
# Describe a hash if necessary
#
sub describep($)
{
  my ($ref) = @_;

  if ($ref =~ /^[0-9a-f]{40}$/)
  {
    my $newref;
    chomp($newref = `git describe $ref`);
    $ref = $newref if ($newref && $? == 0);
  }
  $ref;
}



########################################
#
# Find shortest path through a dag
# Return array of shortest path
#
sub find_shortest($$$$);
sub find_shortest($$$$)
{
  my ($id,$target,$tree,$mark) = @_;

  print STDERR "Looking at node $id\n" if ($OPTIONS{'debug'});

  while ($id ne $target)
  {
    # Is this a merge commit?
    if ($#{$tree->{$id}->{'parent'}} > 0)
    {
      # Is the first parent not a descendant?
      if (!$mark->{$tree->{$id}->{'parent'}->[0]})
      {
	my (@minp);
	my ($mindef);

	# See which parent is the best connected
	foreach my $parent (@{$tree->{$id}->{'parent'}})
	{
	  next unless $mark->{$parent};

	  my (@tmp) = find_shortest($parent,$target,$tree,$mark);

	  if (!$mindef || $#minp > $#tmp)
	  {
	    @minp = @tmp;
	    $mindef = 1;
	  }
	}
	unshift(@minp,$id);
	return(@minp);
      }
    }

    $id = $tree->{$id}->{'parent'}->[0];
  }
  ();
}


foreach my $f (@ARGV)
{
  print "Looking for $f\n++++++++++++++++++++++++++++++++++++++++\n" if ($MULTI);

  # Translate into a commit hash
  my ($TARGET)=`git rev-list -n 1 $f 2>/dev/null`;
  die "Unknown reference $f\n" if ($?);
  chomp($TARGET);

  my (@first,@second);

  if ($OPTIONS{'reference'})
  {
    my $tmp = `git rev-list -n 1 $OPTIONS{'reference'} 2>/dev/null`;
    die "Unknown --reference $OPTIONS{'reference'}\n" if ($?);
    chomp($tmp);
    @first = ($tmp);
  }
  else
  {
    # Generate first pass list of candidate branches
    @first = grep(s/^\*?\s+// && s/\n// && !/ -\> / && (!$OPTIONS{'reference-branch'} || $OPTIONS{'reference-branch'} eq $_),`git branch $OPT_A --contains $f`);

    if ($#first < 0)
    {
      my $msg = "any named branch";
      $msg = "any local named branch" unless ($OPTIONS{'a'});
      $msg = "branch $OPTIONS{'reference-branch'}" if ($OPTIONS{'reference-branch'});
      die "Commit $f has not merged onto $msg yet\n";
    }
  }

  # Shortcut if we might only need direct commit branches
  if (!$OPTIONS{'all'})
  {
    # Look for merge intos to exclude
    foreach my $br (@first)
    {
      # Exclude branches that this commit was merged into
      push(@second,$br) if (grep(/$TARGET/,`git rev-list --first-parent $br`));
    }
  }

  if ($#second >= 0)
  {
    # If branch was subsequently forked via `git branch <old> <new>`
    # we might have multiple answers.  Only one is right, but we
    # cannot figure out which is the privledged branch because the
    # branch creation information is not preserved.

    print join("\n",@second)."\n";
  }
  else
  {
    # Commit is on an anonymous branch, find out where it merged

    my (%brtree,%min);
    foreach my $br (@first)
    {
      my (%commits,@commits);
      my $SOURCE = `git rev-list -n 1 $br 2>/dev/null`;
      die "Cannot find branch reference.  Huh?\n" if ($?);
      chomp($SOURCE);
      print STDERR "Checking branch $br\n" if ($OPTIONS{'debug'});

      # Discover all "ancestry-path" commits between target and branch
      my $cmd = qq^git rev-list --ancestry-path --date-order --format=raw "$TARGET".."$br"^;
      my ($commit);
      foreach my $line (`$cmd`)
      {
	my (@f) = split(/\s+/,$line);
	if ($f[0] eq "commit")
	{
	  $commit = $f[1];
	  $commit =~ s/^-//;	# I have never seen this myself, but Artur Skawina wrote code to defend against it
	  unshift(@commits,$commit);
	}
	if ($f[0] eq "parent")
	{
	  push(@{$commits{$commit}->{'parent'}},$f[1]);
	}
	if ($f[0] eq "committer")
	{
	  $commits{$commit}->{'committime'} = $f[$#f-1];
	}
      }

      print STDERR "Found $#commits+1\n" if ($OPTIONS{'debug'});

      my (@path);

      # Go through commit list (in forward chonological order)
      my (%mark,$cnt);
      $mark{$TARGET} = ++$cnt;
      foreach my $id (@commits)
      {
	next unless $commits{$id}->{'parent'};

	# Check to see if this commit is actually a descent of $TARGET
	if (grep($mark{$_},@{$commits{$id}->{'parent'}}))
	{
	  $mark{$id} = ++$cnt;
	}

	# Is this a merge commit?
	if ($#{$commits{$id}->{'parent'}} > 0)
	{
	  # Is the first parent not a descendant? (earliest merge)
	  if (!$mark{$commits{$id}->{'parent'}->[0]})
	  {
	    push(@path,$id);
	  }
	}
      }

      # Check to make sure we have gone from TARGET or SOURCE via parents
      if (!$mark{$SOURCE})
      {
	# Not connected
	next;
      }

      print STDERR "Found $#path+1 initial path entries\n" if ($OPTIONS{'debug'});

      if ($#path >= 0)
      {
	my $id = $path[$#path];
	@path = find_shortest($id,$TARGET,\%commits,\%mark);
	$brtree{$br}->{'path'} = \@path;
	$brtree{$br}->{'cnt'} = $#path;
	$brtree{$br}->{'tstamp'} = $commits{$id}->{'committime'};

	if ($OPTIONS{'all'})
	{
	  if ($OPTIONS{'quiet'})
	  {
	    print "$br\n";
	  }
	  else
	  {
	    foreach my $mp (@{$brtree{$br}->{'path'}})
	    {
	      push(@{$brtree{$br}->{'committimes'}},$commits{$mp}->{'committime'});
	    }
	  }
	}
	else
	{
	  if (!defined($min{'tstamp'}) ||
	      ($OPTIONS{'topo-order'}?
	       ($min{'cnt'} > $brtree{$br} ||
		($min{'cnt'} == $brtree{$br} &&
		 $min{'tstamp'} > $brtree{$br}->{'tstamp'})):
	       ($min{'tstamp'} > $brtree{$br}->{'tstamp'})))
	  {
	    %min = %{$brtree{$br}};
	    $min{'br'} = $br;
	    $min{'commits'} = \%commits;
	  }
	}
      }
      else
      {
	if ($OPTIONS{'all'})
	{
	  print "$TARGET is on $br\n";
	}
	else
	{
	  print "$br\n";
	}
	$min{'tstamp'} = 0;
	delete($min{'br'});
      }
    }

    if (!$OPTIONS{'all'})
    {
      if ($min{'br'})
      {
	if ($OPTIONS{'quiet'})
	{
	  print "$min{'br'}\n";
	}
	else
	{
	  print "$f first merged onto $min{'br'} using the following minimal".($OPTIONS{'topo-order'}?"":" temporal")." path:\n";
	  my $last = describep($TARGET);
	  foreach my $br (@{$min{'path'}})
	  {
	    my $newm = describep($br);
	    print "  $last merged up at $newm (@{[scalar(localtime($min{'commits'}->{$br}->{'committime'}))]})\n";
	    $last = $newm;
	  }
	  print "  $last is on $min{'br'}\n";
	}
      }
      else
      {
	print "Could not find $f connected anywhere\n" unless defined($min{'tstamp'});
      }
    }
    else
    {
      if (!$OPTIONS{'quiet'})
      {

	sub myorder
	{
	  if ($OPTIONS{'topo-order'})
	  {
	    my $ret = $brtree{$a}->{'cnt'} <=> $brtree{$b}->{'cnt'};
	    $ret = $brtree{$a}->{'tstamp'} <=> $brtree{$b}->{'tstamp'} if (!$ret);
	    $ret;
	  }
	  else
	  {
	    $brtree{$a}->{'tstamp'} <=> $brtree{$b}->{'tstamp'};
	  }
	}


	foreach my $br (sort myorder (keys %brtree))
	{
	  print "* $TARGET first merged onto $br using the following path:\n";
	  my $last = describep($TARGET);
	  foreach my $mp (@{$brtree{$br}->{'path'}})
	  {
	    my $newm = describep($mp);
	    my $ctime = shift(@{$brtree{$br}->{'committimes'}});
	    print "  $last merged up at $newm (@{[scalar(localtime($ctime))]})\n";
	    $last = $newm;
	  }
	  print "  $last is on $br\n";
	}
      }
    }
  }
  print "----------------------------------------\n" if ($MULTI);
}


=pod


=head1 NAME

git-what-branch - Discover what branch a particular commit was made on or near


=head1 SYNOPSIS

git-what-branch [--allref] [--all] [--topo-order | --date-order ] [--quiet] [--reference-branch=branchname] [--reference=reference] <commit-hash/tag>...


=head1 OVERVIEW

Tell us (by default) the earliest causal path of commits and merges to
cause the requested commit got onto a named branch.  If a commit was
made directly on a named branch, that obviously is the earliest path.

By earliest causal path, we mean the path which merged into a named
branch the earliest, by commit time (unless --topo-order is
specified).

You may specify a particular reference branch or tag or revision to
look at instead of searching (by default) the path for all named
branches.  Searching the path for all named branches can take a long
time for an early commit occurring on many branches.  If you
specifically name a reference branch or commit, it should normally
take seconds.


=head1 DESCRIPTION

=head2 --allref

Allow even remote branches to be candidates to see what named branch a
particular commit was make on or merged to.

=head2 --all

If the commit in question was not made directly on a named branch (in
which case all branch names would be printed), the system picks the
named branch which the commit was merged to first and prints only that
path.  With this argument all paths from the commit in question to all
named branches that it was committed onto are printed.

=head2 --topo-order

Instead of selecting the merge path which resulted in the earliest
commit to a named branch, select the merge path which resulted in the
fewest merges.  If multiple merge paths have the same distance, use
earliest merge to break ties.

=head2 --date-order

The default ordering where the merge path which resulted in the
earliest commit to a named branch is displayed.

=head2 --quiet

If the commit was not made on a branch, do not print the path from the
commit to the named branch, just print the branch name.

=head2 --reference-branch <branchname>

Instead of looking at all branches which contain a specific commit,
look only at the named branch.  This will save a great deal of time if
many branches contain the commits in question.

=head2 --reference <tagname/commithash>

Instead of looking to see what branch the commit was in, look to see
how the commit got to a specific tag or other commit.  This would be
useful to determine if a particular commit that introduced a bug (or a
fix) was in a particular release, for example.


=head1 PERFORMANCE

If many branches (e.g. hundreds) contain the commit, the system may
take a long time (for a particular commit in the linux tree, it took 8
second to explore a branch, but there were over 200 candidate
branches) to track down the path to each commit.  Selection of a
particular --reference-branch --reference tag to examine will be
hundreds of times faster (if you have hundreds of candidate branches).


=head1 EXAMPLES

 # git-what-branch 1f9c381fa3e0b9b9042e310c69df87eaf9b46ea
 1f9c381fa3e0b9b9042e310c69df87eaf9b46ea4 first merged onto v2.6.12-n using the following minimal path:
   v2.6.12-rc3-450-g1f9c381 merged up at v2.6.12-rc3-590-gbfd4bda (Thu May  5 08:59:37 2005)
   v2.6.12-rc3-590-gbfd4bda merged up at v2.6.12-rc3-461-g84e48b6 (Tue May  3 18:27:24 2005)
   v2.6.12-rc3-461-g84e48b6 is on v2.6.12-n


=head1 BUGS

git fast-forward merges make changes to branches without reflecting
that history in a merge commit.  This means that when later reviewing
that history, git may label (via --first-parent) the wrong branch as
being named a specific name.  Any lies which git makes are reflected
in the output of this program.

Branches which are created after the commit you are interested in has
been merged into another named branch you are interested in cannot be
distinguished from the original branch.  Example if you have master
branch, you make commit A, then make a release branch named v1.0,
after branch v1.0 has been created there is no way to know that v1.0
was created later and so both branches will be listed as the branches
that commit A was made on.  If git recorded when a branch was created,
we could avoid this problem.

If multiple branches (say due to the previous bug) are candidates and
the commit was NOT made directly on a named branch but rather on an
anonymous branch that was merged, unless you request --all, a
pseudo-random branch will be chosen as the branch advertised via the
merge path.


=head1 ACKNOWLEDGMENTS

Thanks to Artur Skawina for his assistance in developing some
of the algorithms used by this script.


=head1 COPYRIGHT/LICENSE

License: GPL v2
Copyright (c) 2010 Seth Robertson
